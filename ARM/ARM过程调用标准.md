# ARM的子程序调用

## 数据格式

### 字节序

arm支持little-endian和big-endian，具体是哪种取决于硬件实现。
在一个数据类型中，最低有效位始终是bit0。也就是说，little-endian和big-endian只影响多字节类型中的字节序，
而一个字节内部的bit顺序是始终统一的。

### 对齐

联合体的对齐以它最对齐的成员为准，一个联合体的大小；
数组的对齐是以其基本类型为准，数组大小是基本类型大小乘以数量；

## 核心寄存器

共有16个32位寄存器对ARM和Thumb指令集可见，用r0-r15或R0-R15表示。
其中R15是PC寄存器，R14是是连接寄存器，存储返回地址或者中断标识；R13是SP,栈指针。
R0-R3用于向子程序传递参数和函数返回值，也可以用于存放中间值，通常是在子程序调用之间。
R4-R8,R10,R11用于存放例程的本地变量，也就是C语言中的非静态局部变量。当然不要求Thumb代码仅仅使用这些
寄存器。
R4-R8,R11,SP是被调用者保存的寄存器，如果被调用者要使用这些寄存器，必须要先压栈，然后返回之前
出栈恢复这些寄存器。


## 栈结构

一个进程有其对应的程序状态和可访问的存储器内容，这些是运行时可变的。
进程的内存空间共分为5个区域：

* 代码（必须可读，不需要可写）
* 只读静态数据
* 可写静态数据
* 堆
* 栈

其中，可写静态数据分为：已初始化，零初始化，未初始化3类。除了栈，其他区域都不需要
占用单个连续范围的内存。一个进程必须有代码和栈，其他类型都是可选的。
堆区是由进程自己管理和使用的，例如使用C语言标准库的malloc函数。堆区典型的用途是
用于创建动态数据对象。

栈必须是连续内存区域，可用于存储本地变量和当寄存器不够用时向子程序传递更多的参数
栈是向低地址方向生长的，当前的栈顶放在SP寄存器中。其中栈底成为栈基，栈顶成为栈限制。
在任何时刻，SP寄存器必须满足：
Stack-limit < SP <= stack-base 栈指针必须在指定范围内。
SP mod 4 = 0 栈指针必须子对齐
过程只能访问 [SP,stack-base-1] 范围内的内存



## 子程序调用

ARM和Thumb指令集都包含基本子例程调用指令BL。

BL指令执行分支并连接的操作。具体来说
就是把PC的下一个值，也就是返回地址（子例程结束后从此处开始执行)，放入到LR寄存器。
由于返回地址必须对齐，所以返回地址的bit0必定是0。因此LR寄存器中的bit0 被用于表示
当前指令集状态，1表示Thumb状态，0表示ARM状态。

设置完LR后，把子例程的地址放入到PC中。接下来就会执行子例程，需要返回是则把LR中的值
载入到PC中。

需要注意的是BL指令并不能使用全部的32位地址空间。

## 返回值

返回值的传递方式取决于返回值的类型。对于基本类型：

* 半精度浮点数 r0的低16位
* 低于4字节的基础类型 符号扩展或零扩展后用r0返回
* 一个字大小的基础类型 用r0返回
* 双子大小的基本类型(long long double) 用r0和r1返回
* 128bit 容器向量 用r0-r3返回
* 不大于4字节的复合类型 用r0返回，格式等效于结果在内存中，然后用LDR指令载入到
  r0中相同
* 大于4字节的复合类型，或大小无法被调用者和被调者确定的复合类型 
  用内存返回，地址在调用时作为额外的参数传递。用于返回值的内存区域在
  调用过程中可以被修改

## 参数传递

参数传递使用r0-r3以及栈。对于只有少量参数的子例程调用，只需使用寄存器
降低了调用开销。
参数传递分为两个层次：

* 从源编程语言的类型到机器类型的映射
* 整理机器类型，产生最终的参数表

